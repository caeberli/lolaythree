import { AlchemyEventFilter, AlchemyEventType, AlchemyMinedTransactionsAddress, AlchemyMinedTransactionsEventFilter, AlchemyPendingTransactionsEventFilter, NonEmptyArray } from '../types/types';
import { Event } from './internal-types';
/**
 * Wrapper class around the ethers `Event` class in order to add support for
 * Alchemy's custom subscriptions types.
 *
 * The serialization and deserialization mechanism requires the order of the
 * fields to be the same across different {@link ALCHEMY_EVENT_TYPES}. Before
 * using a getter on a new event filter, make sure that the position of the
 * field in serialization is correct.
 *
 * The getters on this class deserialize the event tag generated by
 * {@link getAlchemyEventTag} into the original fields passed into the event.
 */
export declare class EthersEvent extends Event {
    /**
     * Converts the event tag into the original `fromAddress` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get fromAddress(): string | string[] | undefined;
    /**
     * Converts the event tag into the original `toAddress` field in
     * {@link AlchemyPendingTransactionsEventFilter}.
     */
    get toAddress(): string | string[] | undefined;
    /**
     * Converts the event tag into the original `hashesOnly` field in
     * {@link AlchemyPendingTransactionsEventFilter} and {@link AlchemyMinedTransactionsEventFilter}.
     */
    get hashesOnly(): boolean | undefined;
    get includeRemoved(): boolean | undefined;
    get addresses(): NonEmptyArray<AlchemyMinedTransactionsAddress> | undefined;
}
export declare function isAlchemyEvent(event: AlchemyEventType): event is AlchemyMinedTransactionsEventFilter | AlchemyPendingTransactionsEventFilter;
export declare function verifyAlchemyEventName(eventName: AlchemyEventFilter): void;
export declare function deserializeTopics(data: string): any;
